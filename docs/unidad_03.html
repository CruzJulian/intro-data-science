<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MNS - Proyecto: The joy of programming</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">MNS</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-data-vis" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Data-vis</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-data-vis">    
        <li>
    <a class="dropdown-item" href="./data-vis_00_intro.html">
 <span class="dropdown-text">Presentación</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./data-vis_01_r-graphics.html">
 <span class="dropdown-text">R base</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./data-vis_02_ggplot.html">
 <span class="dropdown-text">R ggplot</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./data-vis_03_matplotlib.html">
 <span class="dropdown-text">Python matplotlib</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./data-vis_04_seaborn.html">
 <span class="dropdown-text">Python seaborn</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-taller" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Taller</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-taller">    
        <li>
    <a class="dropdown-item" href="./unidad_00.html">
 <span class="dropdown-text">Presentación</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./unidad_01.html">
 <span class="dropdown-text">Unidad 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./unidad_02.html">
 <span class="dropdown-text">Unidad 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./unidad_03.html">
 <span class="dropdown-text">Unidad 3</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./unidad_04.html">
 <span class="dropdown-text">Unidad 4</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contenido</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción">Introducción</a>
  <ul class="collapse">
  <li><a href="#objetivo-actual" id="toc-objetivo-actual" class="nav-link" data-scroll-target="#objetivo-actual">Objetivo actual</a></li>
  </ul></li>
  <li><a href="#preliminares" id="toc-preliminares" class="nav-link" data-scroll-target="#preliminares">Preliminares</a></li>
  <li><a href="#preparación-de-los-datos" id="toc-preparación-de-los-datos" class="nav-link" data-scroll-target="#preparación-de-los-datos">Preparación de los datos</a></li>
  <li><a href="#evaluación-de-los-grupos-conformados" id="toc-evaluación-de-los-grupos-conformados" class="nav-link" data-scroll-target="#evaluación-de-los-grupos-conformados">Evaluación de los grupos conformados</a>
  <ul class="collapse">
  <li><a href="#evaluación-a-partir-de-información-externa" id="toc-evaluación-a-partir-de-información-externa" class="nav-link" data-scroll-target="#evaluación-a-partir-de-información-externa">Evaluación a partir de información externa</a></li>
  <li><a href="#método-del-codo" id="toc-método-del-codo" class="nav-link" data-scroll-target="#método-del-codo">Método del codo</a></li>
  <li><a href="#validación-cruzada" id="toc-validación-cruzada" class="nav-link" data-scroll-target="#validación-cruzada">Validación cruzada</a></li>
  <li><a href="#coeficiente-silueta" id="toc-coeficiente-silueta" class="nav-link" data-scroll-target="#coeficiente-silueta">Coeficiente Silueta</a></li>
  </ul></li>
  <li><a href="#interpretación" id="toc-interpretación" class="nav-link" data-scroll-target="#interpretación">Interpretación</a>
  <ul class="collapse">
  <li><a href="#visualización-de-los-grupos-conformados" id="toc-visualización-de-los-grupos-conformados" class="nav-link" data-scroll-target="#visualización-de-los-grupos-conformados">Visualización de los grupos conformados</a></li>
  <li><a href="#análisis" id="toc-análisis" class="nav-link" data-scroll-target="#análisis">Análisis</a></li>
  </ul></li>
  <li><a href="#conclusión" id="toc-conclusión" class="nav-link" data-scroll-target="#conclusión">Conclusión</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Proyecto: The joy of programming</h1>
<p class="subtitle lead">Etapa 3 de 4</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introducción" class="level1">
<h1>Introducción</h1>
<p>En esta etapa se aplican los métodos de evaluación de la calidad de los agrupamientos que han sido presentados en el curso para evaluar la calidad de los grupos resultantes de la primera etapa. Al igual que las etapas anteriores, la implementación de los métodos de evaluación se realiza en lenguajes para el manejo de datos R y Python.</p>
<p>Las bases teóricas para la comprensión de los métodos presentados se encuentran en el material del curso. Los métodos que se aplican a continuación son: evaluación a partir de información externa, método del codo, validación cruzada y coeficiente silueta.</p>
<section id="objetivo-actual" class="level2">
<h2 class="anchored" data-anchor-id="objetivo-actual">Objetivo actual</h2>
<p>La tercera etapa del proyecto está orientada a cumplir el tercer objetivo específico:</p>
<blockquote class="blockquote">
<p>Evaluar las tendencias identificadas en los datos de las pinturas y seleccionar el mejor resultado. Caracterizarlo e interpretarlo.</p>
</blockquote>
</section>
</section>
<section id="preliminares" class="level1">
<h1>Preliminares</h1>
<p>En primer lugar debemos cargar las librerías que vamos a utilizar.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"readr"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"magrittr"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>, <span class="at">exclude =</span> <span class="st">"extract"</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"purrr"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"scales"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"factoextra"</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"rsample"</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"cluster"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El código carga un conjunto de librerías que son útiles para diferentes tareas, algunas de ellas son: lectura y escritura de datos, visualización y análisis de clusters.</p>
<ol type="1">
<li><p><strong><code>library("readr")</code></strong>: Carga la librería “readr”, que se utiliza para leer datos en R de manera eficiente. Proporciona funciones como <code>read_csv()</code> para importar datos desde archivos CSV.</p></li>
<li><p><strong><code>library("dplyr")</code></strong>: Carga la librería “dplyr”, una librería muy utilizada para la manipulación y transformación de datos en R. Ofrece funciones como <code>filter()</code>, <code>select()</code>, y <code>mutate()</code>.</p></li>
<li><p><strong><code>library("magrittr")</code></strong>: Carga la librería “magrittr”, que proporciona el operador <code>%&gt;%</code> (pipe), permitiendo encadenar operaciones de manera más legible.</p></li>
<li><p><strong><code>library("ggplot2")</code></strong>: Carga la librería “ggplot2”, una librería popular para la creación de gráficos en R. Utiliza una gramática de gráficos para construir visualizaciones.</p></li>
<li><p><strong><code>library("tidyr", exclude = "extract")</code></strong>: Carga la librería “tidyr”, que se utiliza para trabajar con datos desordenados. La opción <code>exclude = "extract"</code> excluye la función <code>extract()</code> de la carga.</p></li>
<li><p><strong><code>library("purrr")</code></strong>: Carga la librería “purrr”, que proporciona herramientas para trabajar con funciones y datos de manera más efectiva. Es especialmente útil para trabajar con listas.</p></li>
<li><p><strong><code>library("scales")</code></strong>: Carga la librería “scales”, que proporciona funciones para escalar y transformar ejes en gráficos.</p></li>
<li><p><strong><code>library("factoextra")</code></strong>: Carga la librería “factoextra”, que se utiliza para visualizar los resultados de análisis de factores y análisis de componentes principales.</p></li>
<li><p><strong><code>library("rsample")</code></strong>: Carga la librería “rsample”, que proporciona funciones para la validación cruzada y la creación de conjuntos de entrenamiento/prueba.</p></li>
<li><p><strong><code>library("cluster")</code></strong>: Carga la librería “cluster”, que ofrece funciones para realizar análisis de clustering, como K-means y jerárquico.</p></li>
</ol>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> product</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> yellowbrick.cluster <span class="im">import</span> KElbowVisualizer</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> silhouette_score</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El código importa varias librerías y funciones que son útiles para análisis de datos. Estas librerías incluyen herramientas para manipulación de datos (NumPy, Pandas), visualización (Matplotlib, Seaborn), clustering (KMeans), y evaluación de clustering (KElbowVisualizer, silhouette_score).</p>
<ol type="1">
<li><p><strong><code>import numpy as np</code></strong>: Importa la librería NumPy bajo el alias <code>np</code>. NumPy es ampliamente utilizado para operaciones numéricas y matriciales en Python.</p></li>
<li><p><strong><code>import matplotlib.pyplot as plt</code></strong>: Importa la librería Matplotlib bajo el alias <code>plt</code>. Matplotlib se utiliza para la creación de gráficos y visualizaciones en Python.</p></li>
<li><p><strong><code>import os</code></strong>: Importa la librería <code>os</code>, que proporciona funciones para interactuar con el sistema operativo. Puede ser utilizada para manipular rutas de archivos, entre otras cosas.</p></li>
<li><p><strong><code>import pandas as pd</code></strong>: Importa la librería Pandas bajo el alias <code>pd</code>. Pandas es una librería utilizada para manipulación y análisis de datos en Python, proporcionando estructuras de datos como DataFrames.</p></li>
<li><p><strong><code>import seaborn as sns</code></strong>: Importa la librería Seaborn bajo el alias <code>sns</code>. Seaborn es una librería de visualización que trabaja en conjunto con Matplotlib para crear gráficos más atractivos y informativos.</p></li>
<li><p><strong><code>from itertools import product</code></strong>: Importa la función <code>product</code> del módulo <code>itertools</code>. <code>product</code> genera el producto cartesiano de iterables, y en este contexto, podría usarse para crear combinaciones de parámetros para el análisis.</p></li>
<li><p><strong><code>from sklearn.cluster import KMeans</code></strong>: Importa la clase <code>KMeans</code> del módulo <code>sklearn.cluster</code>. <code>KMeans</code> se utiliza para realizar análisis de clustering utilizando el algoritmo k-means.</p></li>
<li><p><strong><code>from sklearn.model_selection import train_test_split</code></strong>: Importa la función <code>train_test_split</code> de <code>sklearn.model_selection</code>. Esta función se utiliza para dividir un conjunto de datos en conjuntos de entrenamiento y prueba.</p></li>
<li><p><strong><code>from yellowbrick.cluster import KElbowVisualizer</code></strong>: Importa la clase <code>KElbowVisualizer</code> de <code>yellowbrick.cluster</code>. <code>KElbowVisualizer</code> es una herramienta de visualización que ayuda a encontrar el número óptimo de clusters en k-means.</p></li>
<li><p><strong><code>from sklearn.metrics import silhouette_score</code></strong>: Importa la función <code>silhouette_score</code> de <code>sklearn.metrics</code>. Esta función calcula el coeficiente de silueta, una métrica que mide cuán similar es un objeto a su propio cluster en comparación con otros clusters.</p></li>
</ol>
</div>
</div>
</div>
<p>Generamos una lista de configuración. Esto es una buena práctica de programación en ciencia de datos. En esta lista vamos a almacenar información que utilizaremos en el código de forma reiterada.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-2-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-1" role="tab" aria-controls="tabset-2-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-2-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-2" role="tab" aria-controls="tabset-2-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-2-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-2-1-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>mi_setup <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">datos_pinturas =</span> <span class="fu">file.path</span>(<span class="st">"01_data"</span>, <span class="st">"bob-ross.csv"</span>),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">archivo_grupos =</span> <span class="fu">file.path</span>(<span class="st">"01_data"</span>, <span class="st">"resultados_r_01.csv"</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="fu">theme_set</span>(<span class="fu">theme_minimal</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Este código genera una lista de configuración. En esta lista se guardan las rutas y otros parámetros que se usan más adelante en el desarrollo.</p>
<ul>
<li><p><strong><code>datos_pinturas</code></strong>: Ruta del archivo “bob-ross.csv” ubicado en la carpeta “01_data”. Este archivo contiene datos relacionados con pinturas de Bob Ross.</p></li>
<li><p><strong><code>archivo_grupos</code></strong>: Ruta del archivo “resultados_r_01.csv” ubicado en la carpeta “01_data”. Este archivo contiene resultados de los grupos obtenidos en el análisis previo.</p></li>
</ul>
<p>Adicionalmente, se configura <code>ggplot2</code> para usar el tema <code>minimal</code> por defecto.</p>
</div>
<div id="tabset-2-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-2-2-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>mi_setup <span class="op">=</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"datos_pinturas"</span>: os.path.join(<span class="st">"01_data"</span>, <span class="st">"bob-ross.csv"</span>), </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"archivo_grupos"</span>: os.path.join(<span class="st">"01_data"</span>, <span class="st">"resultados_py_01.csv"</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>sns.set_context(<span class="st">'notebook'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Este código genera una lista de configuración. En esta lista se guardan las rutas y otros parámetros que se usan más adelante en el desarrollo.</p>
<ul>
<li><p><strong><code>datos_pinturas</code></strong>: Ruta del archivo “bob-ross.csv” ubicado en la carpeta “01_data”. Este archivo contiene datos relacionados con pinturas de Bob Ross.</p></li>
<li><p><strong><code>archivo_grupos</code></strong>: Ruta del archivo “resultados_py_01.csv” ubicado en la carpeta “01_data”. Este archivo contiene resultados de los grupos obtenidos en el análisis previo.</p></li>
</ul>
<p>Adicionalmente se configura <code>seaborn</code> para usar el tema <code>whitegrid</code> y el contexto <code>notebook</code> por defecto.</p>
</div>
</div>
</div>
<p>Leemos nuestro archivo de datos.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-3-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-1" role="tab" aria-controls="tabset-3-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-3-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-2" role="tab" aria-controls="tabset-3-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-3-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-3-1-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">read_csv</span>(mi_setup<span class="sc">$</span>datos_pinturas) <span class="ot">-&gt;</span> tb_pinturas</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fu">read_csv</span>(mi_setup<span class="sc">$</span>archivo_grupos) <span class="ot">-&gt;</span> tb_grupos</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Se utiliza las función <code>read_csv</code> de la librería <code>readr</code> para leer archivos CSV y se asignan los resultados a dos dataframes: <code>tb_pinturas</code> y <code>tb_grupos</code>. Aquí está la explicación:</p>
<ul>
<li><p><strong><code>read_csv(mi_setup$datos_pinturas) -&gt; tb_pinturas</code></strong>: Se lee el archivo CSV cuya ruta está especificada en <code>mi_setup$datos_pinturas</code> utilizando la función <code>read_csv</code> del paquete <code>readr</code>. El dataframe resultante se asigna a la variable <code>tb_pinturas</code>.</p></li>
<li><p><strong><code>read_csv(mi_setup$archivo_grupos) -&gt; tb_grupos</code></strong>: Similar a la primera línea, se lee el archivo CSV cuya ruta está en <code>mi_setup$archivo_grupos</code>. El dataframe resultante se asigna a la variable <code>tb_grupos</code>.</p></li>
</ul>
</div>
<div id="tabset-3-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-3-2-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>tb_pinturas <span class="op">=</span> pd.read_csv(mi_setup[<span class="st">"datos_pinturas"</span>])</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>tb_grupos <span class="op">=</span> pd.read_csv(mi_setup[<span class="st">"archivo_grupos"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Utilizando la librería <code>pandas</code>, mediante la función <code>pd.read_csv</code> se leen los archivos CSV y se asignan los resultados a dos DataFrames: <code>tb_pinturas</code> y <code>tb_grupos</code>. Aquí está la explicación:</p>
<ul>
<li><p><strong><code>tb_pinturas = pd.read_csv(mi_setup["datos_pinturas"])</code></strong>: Se lee el archivo CSV cuya ruta está especificada en <code>mi_setup["datos_pinturas"]</code>. El DataFrame resultante se asigna a la variable <code>tb_pinturas</code>.</p></li>
<li><p><strong><code>tb_grupos = pd.read_csv(mi_setup["archivo_grupos"])</code></strong>: Similar a la primera línea, se lee el archivo CSV cuya ruta está en <code>mi_setup["archivo_grupos"]</code>. El DataFrame resultante se asigna a la variable <code>tb_grupos</code>.</p></li>
</ul>
</div>
</div>
</div>
</section>
<section id="preparación-de-los-datos" class="level1">
<h1>Preparación de los datos</h1>
<p>Seleccionamos las columnas con las que vamos a realizar nuestros análisis. En este caso se trata de todas las columnas de atributos de las pinturas.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-4-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-1" role="tab" aria-controls="tabset-4-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-4-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-2" role="tab" aria-controls="tabset-4-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-4-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-4-1-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>tb_pinturas <span class="sc">%&gt;%</span> </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span> EPISODE, <span class="sc">-</span> TITLE) <span class="ot">-&gt;</span> tb_pinturas_caract</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Se utiliza el operador <code>%&gt;%</code> de la biblioteca <code>dplyr</code> para realizar una operación de selección de columnas en el DataFrame <code>tb_pinturas</code>. Aquí se explica paso a paso:</p>
<ul>
<li><p><strong><code>tb_pinturas %&gt;%</code></strong>: El operador <code>%&gt;%</code> (pipe) se utiliza para pasar el objeto <code>tb_pinturas</code> al siguiente paso de la cadena de operaciones.</p></li>
<li><p><strong><code>select(- EPISODE, - TITLE)</code></strong>: Se utiliza la función <code>select</code> del paquete <code>dplyr</code> para elegir columnas específicas del DataFrame <code>tb_pinturas</code>. La notación <code>-</code> se utiliza para excluir las columnas llamadas “EPISODE” y “TITLE”. Esto significa que todas las columnas excepto “EPISODE” y “TITLE” serán seleccionadas.</p></li>
<li><p><strong><code>-&gt; tb_pinturas_caract</code></strong>: El resultado de la selección se asigna a un nuevo DataFrame llamado <code>tb_pinturas_caract</code>.</p></li>
</ul>
</div>
<div id="tabset-4-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-4-2-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>tb_pinturas_caract <span class="op">=</span> tb_pinturas.drop([<span class="st">"EPISODE"</span>, <span class="st">"TITLE"</span>], axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Este código elimina las columnas “EPISODE” y “TITLE” del DataFrame <code>tb_pinturas</code>, y el resultado se guarda en un nuevo DataFrame llamado <code>tb_pinturas_caract</code>. Se realiza una operación de eliminación de columnas en el DataFrame <code>tb_pinturas</code>. Aquí se explica paso a paso:</p>
<p><strong><code>tb_pinturas_caract = tb_pinturas.drop(["EPISODE", "TITLE"], axis=1)</code></strong>: Se utiliza el método <code>drop</code> de pandas para eliminar las columnas “EPISODE” y “TITLE” del DataFrame <code>tb_pinturas</code>. El argumento <code>axis=1</code> indica que la operación se realiza a lo largo de las columnas.</p>
</div>
</div>
</div>
</section>
<section id="evaluación-de-los-grupos-conformados" class="level1">
<h1>Evaluación de los grupos conformados</h1>
<p>Las siguientes secciones muestran la evaluación de los grupos conformados por medio de distintos métodos. La implementación de los métodos vistos presenta una exigencia media a nivel de programación. Es necesario escribir funciones y ciclos. No obstante, todo se encuentra explicado en detalle.</p>
<p>En nuestro proyecto tenemos la tarea de encontrar grupos de pinturas de acuerdo con los objetos presentes en ellas. El desarrollo de estos códigos nos permite evaluar los grupos que conformamos en la primera unidad e interpretar estos grupos.</p>
<section id="evaluación-a-partir-de-información-externa" class="level2">
<h2 class="anchored" data-anchor-id="evaluación-a-partir-de-información-externa">Evaluación a partir de información externa</h2>
<p>Para nuestro dataset de pinturas no tenemos el caso de información externa; pero podemos simular un escenario muy parecido. En primer lugar debemos programar la función <code>ps</code>, que nos permite obtener la <strong>fuerza de predicción</strong> de un sistema de grupos estimados sobre un sistema de grupos verdaderos. El código es el siguiente:</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-5-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-5-1" role="tab" aria-controls="tabset-5-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-5-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-5-2" role="tab" aria-controls="tabset-5-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-5-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-5-1-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ps <span class="ot">&lt;-</span> <span class="cf">function</span>(true_groups, estim_groups){</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sprintf</span>(<span class="st">"Id_%04d"</span>, <span class="fu">seq_along</span>(true_groups)) <span class="ot">-&gt;</span> id_data</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">setNames</span>(</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    true_groups,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    id_data</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">-&gt;</span> vc_true</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">setNames</span>(</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    estim_groups,</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    id_data</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">-&gt;</span> vc_estim</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="fu">expand_grid</span>(<span class="at">id_1 =</span> id_data, <span class="at">id_2 =</span> id_data) <span class="sc">%&gt;%</span> </span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">true_1 =</span> vc_true[id_1],</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">true_2 =</span> vc_true[id_2],</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">paired_true =</span> <span class="fu">as.numeric</span>(true_1 <span class="sc">==</span> true_2),</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="at">estim_1 =</span> vc_estim[id_1],</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">estim_2 =</span> vc_estim[id_2],</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">paired_estim =</span> <span class="fu">as.numeric</span>(estim_1 <span class="sc">==</span> estim_2),</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="at">no_perm =</span> <span class="fu">as.numeric</span>(paired_true <span class="sc">&gt;</span> paired_estim)</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span> </span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(true_1) <span class="sc">%&gt;%</span> </span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    <span class="at">paired_true =</span> <span class="fu">sum</span>(paired_true),</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="at">no_perm =</span> <span class="fu">sum</span>(no_perm)</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span> </span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(paired_true <span class="sc">!=</span> <span class="dv">1</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    <span class="at">ps =</span> <span class="dv">1</span> <span class="sc">-</span> no_perm<span class="sc">/</span>(paired_true <span class="sc">-</span> <span class="fu">sqrt</span>(paired_true))</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(ps) <span class="sc">%&gt;%</span> min <span class="ot">-&gt;</span> PS</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>  PS</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esta función calcula la fuerza de predicción (PS) basada en la comparación de grupos verdaderos y estimados utilizando permutaciones. La lógica exacta detrás del cálculo de la fuerza de predicción reside en la manipulación de datos y las transformaciones realizadas en el dataframe generado por <code>expand_grid</code>.</p>
<ol type="1">
<li><p><strong>Generación de identificadores únicos (<code>id_data</code>):</strong></p>
<ul>
<li><p>Se crea una lista de identificadores únicos formateados como “Id_XXXX”, donde XXXX representa un número secuencial de cuatro dígitos. La longitud de la lista está determinada por la cantidad de elementos en <code>true_groups</code>.</p></li>
<li><p><code>sprintf("Id_%04d", seq_along(true_groups)) -&gt; id_data</code>: Crea un vector de identificación (<code>id_data</code>) utilizando la función <code>sprintf</code> para formatear números como cadenas de texto con un patrón específico <code>("Id_%04d")</code> agregando ceros a la izquierda a la secuencia <code>seq_along(true_groups)</code> de números que van desde 1 hasta la longitud de <code>true_groups</code>.</p></li>
</ul></li>
<li><p><strong>Creación de diccionarios para mapeo (<code>vc_true</code> y <code>vc_estim</code>):</strong></p>
<ul>
<li><p>Se crean diccionarios que mapean los identificadores a los valores correspondientes en los grupos verdaderos (<code>vc_true</code>) y estimados (<code>vc_estim</code>).</p></li>
<li><p><code>setNames(true_groups, id_data) -&gt; vc_true</code>: Asigna nombres al vector <code>true_groups</code> utilizando los identificadores en <code>id_data</code>. El resultado se guarda en <code>vc_true</code>.</p></li>
<li><p><code>setNames(estim_groups, id_data) -&gt; vc_estim</code>: Similar al paso anterior, asigna nombres al vector <code>estim_groups</code> utilizando los identificadores en <code>id_data</code>. El resultado se guarda en <code>vc_estim</code>.</p></li>
</ul></li>
<li><p><strong>Generación de dataframe con todas las combinaciones posibles:</strong></p>
<ul>
<li><p>Se generan todas las combinaciones posibles de pares de identificadores en <code>id_data</code>. Estos pares se convierten en columnas ‘id_1’ y ‘id_2’.</p></li>
<li><p><code>expand_grid(id_1 = id_data, id_2 = id_data) %&gt;% ...</code>: Utiliza la función <code>expand_grid</code> para crear un dataframe con todas las combinaciones posibles de identificadores de <code>id_data</code>. Este dataframe contiene las columnas <code>id_1</code> e <code>id_2</code>, que son todas las parejas posibles de observaciones. El operador <code>%&gt;%</code> (pipe) da continuidad a la aplicación de operaciones y transformaciones.</p></li>
</ul></li>
<li><p><strong>Mapeo de valores verdaderos y estimados:</strong></p>
<ul>
<li><p>Se agregan columnas al dataFrame <code>df</code> que contienen los valores correspondientes a ‘id_1’ y ‘id_2’ para ambos grupos verdaderos y estimados.</p></li>
<li><p><code>mutate(...)</code>: Agrega nuevas columnas al dataframe.</p></li>
<li><p>Se crean las columnas <code>true_1</code> y <code>true_2</code>, que muestran en qué grupo, de los grupos verdaderos, se encuentran las observaciones correspondientes a las columnas <code>id_1</code> e <code>id_2</code> y la columna <code>paired_true</code> que indica que la pareja correspondiente a <code>id_1</code> e <code>id_2</code> se encuentra en el mismo grupo verdadero.</p></li>
<li><p>Análogamente, se crean las columnas <code>estim_1</code>y <code>estim_2</code>, que muestran en qué grupo, de los grupos estimados, se encuentran las observaciones correspondientes a las columnas <code>id_1</code> e <code>id_2</code> y la columna <code>paired_estim</code>que indica que la pareja correspondiente a <code>id_1</code> e <code>id_2</code> se encuentra en el mismo grupo estimado.</p></li>
</ul></li>
<li><p><strong>Cálculo de <code>no_perm</code>:</strong></p>
<ul>
<li><p>Se compara el número de parejas coincidentes entre <code>paired_true</code> y <code>paired_estim</code>, y se almacena en la columna <code>no_perm</code>. Luego, se agrupa el DataFrame por los valores verdaderos (‘true_1’) y se realiza un resumen.</p></li>
<li><p>La columna <code>no_perm</code> muestra los casos en los que una pareja en el mismo grupo verdadero (<code>paired_true = 1</code>) no se encuentra en el mismo grupo estimado (<code>paired_estim = 0</code>); es decir, es una pareja que no es permanente.</p></li>
<li><p><code>group_by(true_1) %&gt;% summarise(...)</code>: Agrupa los datos por la columna <code>true_1</code> y calcula la suma de <code>paired_true</code> y <code>no_perm</code> para cada grupo. Con esto se tiene la cantidad de parejas en los grupos reales (<code>paired_true</code>) y la cantidad de parejas que no son permanentes para cada cluster verdadero.</p></li>
</ul></li>
<li><p><strong>Cálculo de la fuerza de predicción (<code>ps</code>):</strong></p>
<ul>
<li><p>Se calcula la fuerza de predicción (<code>ps</code>) utilizando la fórmula específica basada en los valores calculados en el paso anterior.</p></li>
<li><p><code>filter(paired_true != 1) %&gt;% mutate(...)</code>: Retira los grupos verdaderos de un solo elemento; son aquellos donde <code>paired_true</code> es igual a 1.</p></li>
<li><p><code>ps = 1 - no_perm/(paired_true - sqrt(paired_true))</code> calcula la fuerza de predicción para cada grupo verdadero.</p></li>
</ul></li>
<li><p><strong>Devolver el valor mínimo de <code>ps</code> (<code>PS</code>):</strong></p>
<ul>
<li><p>La función devuelve el valor mínimo de la fuerza de predicción calculada.</p></li>
<li><p><code>pull(ps) %&gt;% min -&gt; PS</code>: Extrae la columna <code>ps</code> y calcula el mínimo. El resultado se asigna a la variable <code>PS</code>.</p></li>
<li><p><code>PS</code>: Devuelve el valor calculado de PS.</p></li>
</ul></li>
</ol>
</div>
<div id="tabset-5-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-5-2-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ps(true_groups, estim_groups):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  id_data <span class="op">=</span> [<span class="ss">f"Id_</span><span class="sc">{</span>i<span class="sc">:04d}</span><span class="ss">"</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(true_groups))]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  vc_true <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(id_data, true_groups))</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  vc_estim <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(id_data, estim_groups))</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  df <span class="op">=</span> pd.DataFrame(<span class="bu">list</span>(product(id_data, repeat<span class="op">=</span><span class="dv">2</span>)), columns<span class="op">=</span>[<span class="st">'id_1'</span>, <span class="st">'id_2'</span>])</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">'true_1'</span>] <span class="op">=</span> df[<span class="st">'id_1'</span>].<span class="bu">map</span>(vc_true)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">'true_2'</span>] <span class="op">=</span> df[<span class="st">'id_2'</span>].<span class="bu">map</span>(vc_true)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">'paired_true'</span>] <span class="op">=</span> np.where(df[<span class="st">'true_1'</span>] <span class="op">==</span> df[<span class="st">'true_2'</span>], <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">'estim_1'</span>] <span class="op">=</span> df[<span class="st">'id_1'</span>].<span class="bu">map</span>(vc_estim)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">'estim_2'</span>] <span class="op">=</span> df[<span class="st">'id_2'</span>].<span class="bu">map</span>(vc_estim)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">'paired_estim'</span>] <span class="op">=</span> np.where(df[<span class="st">'estim_1'</span>] <span class="op">==</span> df[<span class="st">'estim_2'</span>], <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  df[<span class="st">'no_perm'</span>] <span class="op">=</span> np.where(df[<span class="st">'paired_true'</span>] <span class="op">&gt;</span> df[<span class="st">'paired_estim'</span>], <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  result_df <span class="op">=</span> df.groupby(<span class="st">'true_1'</span>).agg(paired_true<span class="op">=</span>(<span class="st">'paired_true'</span>, <span class="st">'sum'</span>),</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>  no_perm<span class="op">=</span>(<span class="st">'no_perm'</span>, <span class="st">'sum'</span>)).reset_index()</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>  result_df <span class="op">=</span> result_df[result_df[<span class="st">'paired_true'</span>] <span class="op">!=</span> <span class="dv">1</span>]</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  result_df[<span class="st">'ps'</span>] <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> result_df[<span class="st">'no_perm'</span>] <span class="op">/</span> (result_df[<span class="st">'paired_true'</span>] <span class="op">-</span> np.sqrt(result_df[<span class="st">'paired_true'</span>]))</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>  PS <span class="op">=</span> result_df[<span class="st">'ps'</span>].<span class="bu">min</span>()</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> PS</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La función <code>ps</code> realiza los siguientes pasos:</p>
<ol type="1">
<li><p><strong>Generación de identificadores únicos (<code>id_data</code>):</strong></p>
<ul>
<li><p>Se crea una lista de identificadores únicos formateados como “Id_XXXX”, donde XXXX representa un número secuencial de cuatro dígitos. La longitud de la lista está determinada por la cantidad de elementos en <code>true_groups</code>.</p></li>
<li><p><code>range(len(true_groups))</code>: Genera una secuencia de números desde 0 hasta la longitud de la lista <code>true_groups</code> menos 1. Esto proporciona índices únicos para cada elemento en la lista <code>true_groups</code>.</p></li>
<li><p><code>f"Id_{i:04d}"</code>: Utiliza una cadena de formato f-string para crear cadenas de texto con el formato “Id_XXXX”, donde XXXX representa el índice con un relleno de ceros a la izquierda para asegurar que siempre tenga cuatro dígitos.</p></li>
<li><p><code>[...]</code>: Comprende la comprensión de listas, que es una forma concisa de crear listas. En este caso, se genera una lista que contiene las cadenas de texto resultantes.</p></li>
</ul></li>
<li><p><strong>Creación de diccionarios para mapeo (<code>vc_true</code> y <code>vc_estim</code>):</strong></p>
<ul>
<li><p>Se crean diccionarios que mapean los identificadores a los valores correspondientes en los grupos verdaderos (<code>vc_true</code>) y estimados (<code>vc_estim</code>).</p></li>
<li><p><code>zip(id_data, true_groups)</code>: Combina los elementos de las listas <code>id_data</code> y <code>true_groups</code> en pares de tuplas. Cada tupla contiene un elemento de <code>id_data</code> emparejado con el correspondiente elemento de <code>true_groups</code>.</p></li>
<li><p><code>dict(...)</code>: Convierte las tuplas generadas por <code>zip</code> en un diccionario, donde el primer elemento de cada tupla (de <code>id_data</code>) se convierte en la clave y el segundo elemento (de <code>true_groups</code>) se convierte en el valor.</p></li>
<li><p><code>vc_true = dict(zip(id_data, true_groups))</code> crea un diccionario (<code>vc_true</code>) donde cada identificador único en <code>id_data</code> se asigna al valor correspondiente en <code>true_groups</code>.</p></li>
<li><p><code>vc_estim = dict(zip(id_data, estim_groups))</code> realiza la misma operación pero para las listas <code>id_data</code> y <code>estim_groups</code>, creando un diccionario (<code>vc_estim</code>) con los valores estimados asociados a los identificadores únicos.</p></li>
</ul></li>
<li><p><strong>Generación de dataframe con todas las combinaciones posibles (<code>df</code>):</strong></p>
<ul>
<li><p>Se utiliza la función <code>product</code> del módulo <code>itertools</code> para generar todas las combinaciones posibles de pares de identificadores en <code>id_data</code>. Estos pares se convierten en columnas ‘id_1’ y ‘id_2’ en el dataframe <code>df</code>.</p></li>
<li><p><code>product(id_data, repeat=2)</code>: Utiliza la función <code>product</code> del módulo <code>itertools</code> para generar todas las combinaciones posibles de pares de elementos en la lista <code>id_data</code>. El parámetro <code>repeat=2</code> indica que se deben generar combinaciones de longitud 2 (pares).</p></li>
<li><p><code>list(...)</code>: Convierte el objeto iterable resultante de <code>product</code> en una lista.</p></li>
<li><p><code>pd.DataFrame(...)</code>: Crea un dataframe de Pandas a partir de la lista generada. El dataframe tendrá dos columnas llamadas ‘id_1’ y ‘id_2’.</p></li>
<li><p><code>df = pd.DataFrame(list(product(id_data, repeat=2)), columns=['id_1', 'id_2'])</code> crea un dataframe donde cada fila contiene todas las combinaciones posibles de pares de identificadores únicos en <code>id_data</code>. Cada par de identificadores se coloca en las columnas ‘id_1’ e ‘id_2’, respectivamente.</p></li>
</ul></li>
<li><p><strong>Mapeo de valores verdaderos y estimados en el dataframe (<code>df</code>):</strong></p>
<ul>
<li><p>Se agregan columnas al dataframe <code>df</code> que contienen los valores correspondientes a ‘id_1’ y ‘id_2’ para ambos grupos verdaderos y estimados.</p></li>
<li><p>Se crean las columnas <code>true_1</code> y <code>true_2</code>, que muestran en qué grupo, de los grupos verdaderos, se encuentran las observaciones correspondientes a las columnas <code>id_1</code> e <code>id_2</code> y la columna <code>paired_true</code> que indica que la pareja correspondiente a <code>id_1</code> e <code>id_2</code> se encuentra en el mismo grupo verdadero.</p></li>
<li><p>Análogamente, se crean las columnas <code>estim_1</code>y <code>estim_2</code>, que muestran en qué grupo, de los grupos estimados, se encuentran las observaciones correspondientes a las columnas <code>id_1</code> e <code>id_2</code> y la columna <code>paired_estim</code>que indica que la pareja correspondiente a <code>id_1</code> e <code>id_2</code> se encuentra en el mismo grupo estimado.</p></li>
</ul></li>
<li><p><strong>Cálculo de <code>no_perm</code> y <code>result_df</code>:</strong></p>
<ul>
<li><p>Se compara el número de parejas coincidentes entre <code>paired_true</code> y <code>paired_estim</code>, y se almacena en la columna <code>no_perm</code>. Luego, se agrupa el DataFrame por los valores verdaderos (‘true_1’) y se realiza un resumen.</p></li>
<li><p>La columna <code>no_perm</code> muestra los casos en los que una pareja en el mismo grupo verdadero (<code>paired_true = 1</code>) no se encuentra en el mismo grupo estimado (<code>paired_estim = 0</code>); es decir, es una pareja que no es permanente.</p></li>
<li><p><code>result_df = df.groupby('true_1')</code>: Agrupa los datos por la columna <code>true_1</code>.</p></li>
<li><p><code>.agg(paired_true=('paired_true', 'sum'), no_perm=('no_perm', 'sum'))</code> calcula la suma de <code>paired_true</code> y <code>no_perm</code> para cada grupo. Con esto se tiene la cantidad de parejas en los grupos reales (<code>paired_true</code>) y la cantidad de parejas que no son permanentes para cada cluster verdadero.</p></li>
</ul></li>
<li><p><strong>Cálculo de la fuerza de predicción (<code>ps</code>):</strong></p>
<ul>
<li><p>Se calcula la fuerza de predicción (<code>ps</code>) utilizando la fórmula específica basada en los valores calculados en el paso anterior.</p></li>
<li><p><code>result_df[result_df['paired_true'] != 1]</code>: Retira los grupos verdaderos de un solo elemento; son aquellos donde <code>paired_true</code> es igual a 1.</p></li>
<li><p><code>result_df['ps'] = 1 - result_df['no_perm'] / (result_df['paired_true'] - np.sqrt(result_df['paired_true']))</code> calcula la fuerza de predicción para cada grupo verdadero.</p></li>
</ul></li>
<li><p><strong>Devolver el valor mínimo de <code>ps</code> (<code>PS</code>):</strong></p>
<ul>
<li><p>La función devuelve el valor mínimo de la fuerza de predicción calculada.</p></li>
<li><p><code>PS = result_df['ps'].min()</code>: Extrae la columna <code>ps</code> y calcula el mínimo. El resultado se asigna a la variable <code>PS</code>.</p></li>
<li><p><code>return PS</code>: Devuelve el valor calculado de PS.</p></li>
</ul></li>
</ol>
</div>
</div>
</div>
<p>Ya con nuestra función <code>ps</code>, podemos simular el caso de la información externa. Supongamos que tenemos una columna que distribuye las pinturas en 16 grupos dependiendo de si presentan o no montañas, playas, estructuras o invierno. Para fines prácticos, estas 16 categorías se toman como las categorías verdaderas y se mide la aproximación de los grupos conformados previamente con estas categorías. Para eso utilizamos la función <code>ps</code> de la siguiente manera:</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-6-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-1" role="tab" aria-controls="tabset-6-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-6-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-2" role="tab" aria-controls="tabset-6-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-6-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-6-1-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>tb_pinturas_caract <span class="sc">%&gt;%</span> </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">true_clust =</span> <span class="fu">sprintf</span>(<span class="st">"%d%d%d%d"</span>, MOUNTAIN, BEACH, STRUCTURE, WINTER)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(true_clust) <span class="ot">-&gt;</span> true_cluster</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span>(true_cluster, tb_grupos<span class="sc">$</span>grupos_jerar)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span>(true_cluster, tb_grupos<span class="sc">$</span>grupos_kmeans)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span>(true_cluster, tb_grupos<span class="sc">$</span>grupos_dbscan)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El código crea una nueva variable llamada <code>true_clust</code> en el dataframe <code>tb_pinturas_caract</code>, que representa un código de cluster formado por la concatenación de las variables <code>MOUNTAIN</code>, <code>BEACH</code>, <code>STRUCTURE</code>, y <code>WINTER</code>. Luego, se extrae esa variable y se asigna a la variable <code>true_cluster</code>. Esta variable se toma como una agrupación verdadera para probar la evaluación a partir de información externa.</p>
<ul>
<li><p><code>tb_pinturas_caract %&gt;%</code>: Indica que se aplicarán operaciones al objeto <code>tb_pinturas_caract</code> utilizando un pipe (<code>%&gt;%</code>), lo que significa que el resultado de la operación previa se pasa como argumento a la siguiente operación.</p></li>
<li><p><code>mutate(true_clust = sprintf("%d%d%d%d", MOUNTAIN, BEACH, STRUCTURE, WINTER))</code>: Agrega una nueva columna llamada <code>true_clust</code> al dataframe <code>tb_pinturas_caract</code>. El valor de esta columna se genera utilizando la función <code>sprintf</code> para formatear una cadena de texto. Los valores <code>MOUNTAIN</code>, <code>BEACH</code>, <code>STRUCTURE</code>, y <code>WINTER</code> se concatenan.</p></li>
<li><p><code>%&gt;% pull(true_clust)</code>: Extrae la columna recién creada (<code>true_clust</code>) del dataframe resultante y asigna el resultado a la variable <code>true_cluster</code>. Luego se procede a evaluar los grupos conformados anteriormente contrastándolos con esta columna de grupos verdaderos.</p></li>
</ul>
</div>
<div id="tabset-6-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-6-2-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>true_cluster <span class="op">=</span> tb_pinturas_caract.<span class="bu">apply</span>(</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> row: <span class="st">"</span><span class="sc">{:d}{:d}{:d}{:d}</span><span class="st">"</span>.<span class="bu">format</span>(</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        row[<span class="st">'MOUNTAIN'</span>], row[<span class="st">'BEACH'</span>], row[<span class="st">'STRUCTURE'</span>], row[<span class="st">'WINTER'</span>]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    ), axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>).tolist()</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>ps(true_cluster, tb_grupos[<span class="st">'grupos_jerar'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>ps(true_cluster, tb_grupos[<span class="st">'grupos_kmeans'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>ps(true_cluster, tb_grupos[<span class="st">'grupos_dbscan'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El código crea la lista <code>true_cluster</code>, donde cada elemento de la lista es una cadena de texto que representa un código de cluster formado por la concatenación de los valores de las columnas ‘MOUNTAIN’, ‘BEACH’, ‘STRUCTURE’, y ‘WINTER’ para cada fila en el DataFrame <code>tb_pinturas_caract</code>. Esta lista se toma como una agrupación verdadera para probar la evaluación a partir de información externa.</p>
<ul>
<li><p><code>tb_pinturas_caract.apply(...)</code>: Se utiliza la función <code>apply</code> de Pandas para aplicar una función a lo largo de las filas del DataFrame <code>tb_pinturas_caract</code>.</p></li>
<li><p><code>lambda row: "{:d}{:d}{:d}{:d}".format(...)</code>: Se define una función lambda que toma una fila (<code>row</code>) del DataFrame y devuelve una cadena de texto formateada. En este caso, la cadena de texto se forma concatenando los valores de las columnas ‘MOUNTAIN’, ‘BEACH’, ‘STRUCTURE’, y ‘WINTER’.</p></li>
<li><p><code>axis=1</code>: Indica que la función lambda se aplicará a lo largo de las filas.</p></li>
<li><p><code>.tolist()</code>: Convierte el resultado a una lista. Luego se procede a evaluar los grupos conformados anteriormente contrastándolos con esta columna de grupos verdaderos.</p></li>
</ul>
</div>
</div>
</div>
<p>¿Cuánto da cada resultado? ¿Cómo se interpreta? ¿Cuál es el método que mejor se adapta a nuestra variable categórica simulada?</p>
</section>
<section id="método-del-codo" class="level2">
<h2 class="anchored" data-anchor-id="método-del-codo">Método del codo</h2>
<p>El método del codo tiene como objetivo encontrar un número de grupos <span class="math inline">\(k\)</span> óptimo. Por esta razón, suele estar enfocado en la estimación mediante el algoritmo <span class="math inline">\(k\)</span>-means. Veamos la construcción de los tráficos correspondientes.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-7-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-7-1" role="tab" aria-controls="tabset-7-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-7-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-7-2" role="tab" aria-controls="tabset-7-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-7-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-7-1-tab">
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_nbclust</span>(<span class="at">x =</span> tb_pinturas_caract, <span class="at">FUNcluster =</span> kmeans, <span class="at">method =</span> <span class="st">"wss"</span>, <span class="at">k.max =</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="unidad_03_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>El código utiliza la función <code>fviz_nbclust</code> para visualizar diferentes métodos y determinar el número óptimo de clusters en el conjunto de datos <code>tb_pinturas_caract</code>. La métrica evaluada es la suma de los cuadrados dentro de los clusters (WSS), y la visualización puede ayudar a identificar el número óptimo de clusters al observar el codo en la gráfica resultante.</p>
<ol type="1">
<li><p><strong><code>fviz_nbclust(...)</code></strong>: Utiliza la función <code>fviz_nbclust</code> del paquete <code>factoextra</code> para determinar el número óptimo de clusters en un conjunto de datos.</p></li>
<li><p><strong><code>x = tb_pinturas_caract</code></strong>: Se especifica que el conjunto de datos <code>tb_pinturas_caract</code> es el objeto en el que se realizará el análisis de clusters.</p></li>
<li><p><strong><code>FUNcluster = kmeans</code></strong>: Indica que se utilizará el algoritmo de k-means para realizar el análisis de clusters, utilizando la función <code>kmeans</code>.</p></li>
<li><p><strong><code>method = "wss"</code></strong>: Selecciona el método para determinar el número óptimo de clusters. En este caso, se utiliza “wss” (Within-Cluster Sum of Squares), que evalúa la varianza dentro de los clusters.</p></li>
<li><p><strong><code>k.max = 10</code></strong>: Especifica el número máximo de clusters a considerar. En este caso, se evaluará hasta un máximo de 10 clusters.</p></li>
</ol>
</div>
<div id="tabset-7-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-7-2-tab">
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>k_values <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">11</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>kmeans_model <span class="op">=</span> KMeans(n_init <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>visualizer <span class="op">=</span> KElbowVisualizer(kmeans_model, k<span class="op">=</span>k_values, metric<span class="op">=</span><span class="st">'distortion'</span>, timings<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>visualizer <span class="op">=</span> visualizer.fit(tb_pinturas_caract)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>visualizer.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="unidad_03_files/figure-html/unnamed-chunk-16-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El código utiliza el método del codo para determinar el número óptimo de clusters en el conjunto de datos <code>tb_pinturas_caract</code> utilizando el algoritmo de k-medias. La visualización de la distorsión en función del número de clusters ayuda a identificar el punto en el que la distorsión deja de disminuir rápidamente, lo que puede indicar el número óptimo de clusters para el conjunto de datos.</p>
<ol type="1">
<li><p><strong>Definición de <code>k_values</code></strong>: Se crea una secuencia de valores desde 1 hasta 10 para representar diferentes números de clusters.</p></li>
<li><p><strong>Inicialización de <code>kmeans_model</code></strong>: Se crea una instancia del modelo de KMeans (k-medias) con <code>n_init=1</code>, indicando que el algoritmo se ejecutará solo una vez con una inicialización diferente.</p></li>
<li><p><strong>Creación del visualizador <code>visualizer</code></strong>: Se utiliza <code>KElbowVisualizer</code> del paquete <code>yellowbrick</code> para visualizar la métrica de “distorsión” en función del número de clusters. La distorsión mide cuánto se alejan las muestras dentro de un cluster promedio. Se utiliza <code>timings=False</code> para evitar la visualización de tiempos de ejecución.</p></li>
<li><p><strong>Ajuste del modelo al conjunto de datos</strong>: Se ajusta el modelo de k-medias al conjunto de datos <code>tb_pinturas_caract</code> utilizando el método <code>fit()</code> del visualizador.</p></li>
<li><p><strong>Visualización y cierre del gráfico</strong>: Se muestra la visualización generada por el visualizador y se cierra la figura gráfica después de ser visualizada.</p></li>
</ol>
</div>
</div>
</div>
<p>En ambos casos, podemos ver el gráfico del método del codo y establecer un número óptimo de grupos.</p>
</section>
<section id="validación-cruzada" class="level2">
<h2 class="anchored" data-anchor-id="validación-cruzada">Validación cruzada</h2>
<p>Los métodos de validación cruzada se basan en la distribución de dos subconjuntos de datos, para entrenamiento del modelo y para prueba. Siguiendo lo aprendido, en primera instancia debemos escribir una función que realice los siguientes pasos dado un conjunto de datos.</p>
<ol type="1">
<li><p>Divida el conjunto de datos en segmentos de entrenamiento y prueba.</p></li>
<li><p>Estime la estructura de grupos usando el procedimiento a evaluar. En este caso lo realizamos usando <span class="math inline">\(k\)</span>-means, pero podemos cambiar el código para que funcione con otros métodos.</p></li>
<li><p>A partir del modelo estimado por medio de los datos de entrenamiento, pronosticar los grupos correspondientes a los individuos del conjunto de datos de prueba. Estas categorías se toman como <em>categorías verdaderas</em>,</p></li>
<li><p>Ajustar el modelo con los mismos hiperparámetros al conjunto de datos de prueba. De esta forma se obtiene una nueva estructura de grupos. Estas categorías se toman como <em>categorías estimadas</em>.</p></li>
<li><p>Comparar las categorías estimadas con las verdaderas utilizando la función <code>ps</code> definida enteriormente.</p></li>
</ol>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-8-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-8-1" role="tab" aria-controls="tabset-8-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-8-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-8-2" role="tab" aria-controls="tabset-8-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-8-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-8-1-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>ps_cv_k <span class="ot">&lt;-</span> <span class="cf">function</span>(k, tb_data, <span class="at">cv_ratio =</span> <span class="dv">3</span><span class="sc">/</span><span class="dv">4</span>){</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  tb_data <span class="sc">%&gt;%</span> </span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">initial_split</span>(<span class="at">prop =</span> cv_ratio) <span class="ot">-&gt;</span> split_data</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  split_data <span class="sc">%&gt;%</span> </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    training <span class="sc">%&gt;%</span> </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">kmeans</span>(k) <span class="ot">-&gt;</span> ls_kmeans</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  tb_centers <span class="ot">&lt;-</span> ls_kmeans<span class="sc">$</span>centers</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  n_centers <span class="ot">&lt;-</span> <span class="fu">nrow</span>(tb_centers)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>  split_data <span class="sc">%&gt;%</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    testing <span class="sc">%&gt;%</span> </span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rbind</span>(tb_centers) <span class="sc">%&gt;%</span> </span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    dist <span class="sc">%&gt;%</span> </span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    as.matrix <span class="sc">%&gt;%</span> </span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">extract</span>(<span class="fu">seq</span>(n_centers), <span class="sc">-</span><span class="fu">seq</span>(n_centers)) <span class="sc">%&gt;%</span> t <span class="sc">%&gt;%</span> </span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">"-"</span>() <span class="sc">%&gt;%</span> </span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">max.col</span>() <span class="ot">-&gt;</span> vc_predicted</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>  split_data <span class="sc">%&gt;%</span> </span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    testing <span class="sc">%&gt;%</span> </span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span class="fu">kmeans</span>(k) <span class="sc">%&gt;%</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pluck</span>(<span class="st">"cluster"</span>) <span class="ot">-&gt;</span> vc_test_clusters</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ps</span>(vc_predicted, vc_test_clusters)</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Paso 1: <code>tb_data %&gt;% initial_split(prop = cv_ratio) -&gt; split_data</code>. Dividir los datos en conjuntos de entrenamiento y prueba.</p>
<p>Paso 2: <code>split_data %&gt;% training %&gt;% kmeans(k) -&gt; ls_kmeans</code> Aplicar k-medias (kmeans) al conjunto de entrenamiento.</p>
<p>Paso 3: <code>tb_centers &lt;- ls_kmeans$centers; n_centers &lt;- nrow(tb_centers)</code> Obtener los centros de los clusters del modelo k-medias</p>
<p>Paso 4: Determinar el grupo de cada observación en el conjunto de prueba, este se toma como etiqueta verdadera.</p>
<ul>
<li><p><code>split_data %&gt;% testing %&gt;% rbind(tb_centers) %&gt;% dist %&gt;%  ...</code> Calcular las distancias de los puntos de prueba a los centros de los clusters.</p></li>
<li><p><code>extract(seq(n_centers), -seq(n_centers)) %&gt;% t</code> Eliminar las distancias a los propios centros</p></li>
<li><p><code>"-"() %&gt;% max.col() -&gt; vc_predicted</code> Encontrar el índice del centro más cercano para cada punto de prueba.</p></li>
</ul>
<p>Paso 5: Aplicar el algoritmo y encontrar nuevos grupos para los datos de prueba, estos se toman como etiquetas a evaluar.</p>
<ul>
<li><p><code>split_data %&gt;% testing %&gt;% kmeans(k)</code> Aplicar k-medias al conjunto de prueba</p></li>
<li><p><code>pluck("cluster") -&gt; vc_test_clusters</code> Obtener la asignación de clusters para los puntos de prueba</p></li>
</ul>
<p>Paso 6: <code>ps(vc_predicted, vc_test_clusters)</code> Calcular y devolver la medida de validez del clustering (ps).</p>
</div>
<div id="tabset-8-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-8-2-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ps_cv_k(k, tb_data, cv_ratio<span class="op">=</span><span class="dv">3</span><span class="op">/</span><span class="dv">4</span>):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  train_data, test_data <span class="op">=</span> train_test_split(tb_data, test_size<span class="op">=</span><span class="dv">1</span><span class="op">-</span>cv_ratio)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  kmeans_model <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k, n_init<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  kmeans_model <span class="op">=</span> kmeans_model.fit(train_data)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  vc_predicted <span class="op">=</span> kmeans_model.predict(test_data).tolist()</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  kmeans_test <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k, n_init<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  vc_test_clusters <span class="op">=</span> kmeans_test.fit_predict(test_data).tolist()</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ps(vc_predicted, vc_test_clusters)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Paso 1: <code>train_data, test_data = train_test_split(tb_data, test_size=1-cv_ratio)</code> Dividir los datos en conjuntos de entrenamiento y prueba</p>
<p>Paso 2: <code>kmeans_model = KMeans(n_clusters=k, n_init=1); kmeans_model = kmeans_model.fit(train_data)</code> Aplicar k-medias (KMeans) al conjunto de entrenamiento</p>
<p>Paso 3: <code>vc_predicted = kmeans_model.predict(test_data).tolist()</code> Obtener las asignaciones de cluster para los puntos de prueba</p>
<p>Paso 4: <code>kmeans_test = KMeans(n_clusters=k, n_init=1); vc_test_clusters = kmeans_test.fit_predict(test_data).tolist()</code> Aplicar k-medias al conjunto de prueba</p>
<p>Paso 5: <code>return ps(vc_predicted, vc_test_clusters)</code> Calcular y devolver la medida de validez del clustering (ps)</p>
</div>
</div>
</div>
<p>Luego de tener nuestra función lista, resulta sencillo realizar un estudio de simulación que repita la estimación de la fuerza de predicción un número arbitrario de veces. Con esto podemos establecer la distribución de nuestro estadístico de validación y además obtener su promedio.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-9-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-9-1" role="tab" aria-controls="tabset-9-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-9-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-9-2" role="tab" aria-controls="tabset-9-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-9-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-9-1-tab">
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>K_seq <span class="ot">&lt;-</span> <span class="dv">2</span><span class="sc">:</span><span class="dv">10</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span><span class="sc">:</span><span class="dv">50</span>,</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">function</span>(iter){</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">tibble</span>(</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>      <span class="at">iter =</span> iter,</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>      <span class="at">K =</span> K_seq,</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>      <span class="at">PS =</span> <span class="fu">map_dbl</span>(</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        K,</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        ps_cv_k,</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="at">tb_data =</span> tb_pinturas_caract,</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        <span class="at">cv_ratio =</span> <span class="fl">0.6</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>) <span class="sc">%&gt;%</span> <span class="fu">bind_rows</span>() <span class="ot">-&gt;</span> tb_sim</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>tb_sim <span class="sc">%&gt;%</span> <span class="fu">group_by</span>(K) <span class="sc">%&gt;%</span> <span class="fu">summarise</span>(<span class="at">PS =</span> <span class="fu">mean</span>(PS)) <span class="ot">-&gt;</span> tb_sim_mean</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_jitter</span>(<span class="fu">aes</span>(K, PS), tb_sim, <span class="at">size =</span> <span class="fl">0.7</span>) <span class="sc">+</span> </span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(K, PS), tb_sim_mean, <span class="at">colour =</span> <span class="st">"#55aacc"</span>, <span class="at">size =</span> <span class="dv">3</span>) <span class="sc">+</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(K, PS), tb_sim_mean, <span class="at">colour =</span> <span class="st">"#55aacc"</span>, <span class="at">size =</span> <span class="dv">1</span>) <span class="sc">+</span> </span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">breaks =</span> K_seq)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="unidad_03_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>El código realiza 50 iteraciones, en cada iteración evalúa la medida de validez del clustering (PS) para diferentes valores de K utilizando la función ps_cv_k. Luego, se calcula la media de la medida de validez para cada valor de K a lo largo de todas las iteraciones. Finalmente, se visualizan los resultados mediante un gráfico utilizando ggplot2, donde los puntos representan las medidas de validez para cada iteración y el punto y la línea en azul representan la media para cada valor de K. La dispersión de puntos proporciona una idea de la variabilidad de la medida de validez para cada valor de K.</p>
<p>Paso 1: <code>K_seq &lt;- 2:10</code> Definir una secuencia de valores para K (número de clusters)</p>
<p>Paso 2: <code>map(1:50,function(iter){...}) %&gt;%</code> Realizar un mapeo (map) sobre las iteraciones de 1 a 50</p>
<p>Paso 3: <code>tibble(...)</code> Para cada iteración, calcular la medida de validez del clustering (PS)</p>
<p>Paso 4: <code>bind_rows() -&gt; tb_sim</code> Unir los resultados de todas las iteraciones en un solo marco de datos</p>
<p>Paso 5: <code>tb_sim %&gt;% group_by(K) %&gt;% summarise(PS = mean(PS)) -&gt; tb_sim_mean</code> Calcular la media de la medida de validez del clustering para cada valor de K</p>
<p>Paso 6: <code>ggplot() + ...</code> Crear un gráfico utilizando ggplot2 para visualizar los resultados</p>
</div>
<div id="tabset-9-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-9-2-tab">
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>K_seq <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">11</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>tb_sim_list <span class="op">=</span> []</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">iter</span> <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">51</span>):</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  ps_values <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> k: ps_cv_k(k, tb_data<span class="op">=</span>tb_pinturas_caract, cv_ratio<span class="op">=</span><span class="fl">0.6</span>),</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    K_seq</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  iter_data <span class="op">=</span> pd.DataFrame({</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'iter'</span>: [<span class="bu">iter</span>] <span class="op">*</span> <span class="bu">len</span>(K_seq),</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'K'</span>: K_seq,</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">'PS'</span>: ps_values</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>  tb_sim_list.append(iter_data)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>tb_sim <span class="op">=</span> pd.concat(tb_sim_list, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>tb_sim_mean <span class="op">=</span> tb_sim.groupby(<span class="st">'K'</span>)[<span class="st">'PS'</span>].mean().reset_index()</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>sns.stripplot(</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>  x<span class="op">=</span><span class="st">'K'</span>, y<span class="op">=</span><span class="st">'PS'</span>, </span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>  data<span class="op">=</span>tb_sim, size<span class="op">=</span><span class="fl">1.3</span>, legend<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>  color <span class="op">=</span> <span class="st">"black"</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>sns.pointplot(x<span class="op">=</span><span class="st">'K'</span>, y<span class="op">=</span><span class="st">'PS'</span>, data<span class="op">=</span>tb_sim_mean, color<span class="op">=</span><span class="st">'#55aacc'</span>)</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Número de clústeres (K)'</span>)</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Índice de Pureza (PS)'</span>)</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>plt.xticks(K_seq)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="unidad_03_files/figure-html/unnamed-chunk-20-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>código realiza 50 iteraciones, en cada iteración evalúa la medida de validez del clustering (PS) para diferentes valores de K utilizando la función ps_cv_k. Luego, se concatenan los resultados de todas las iteraciones en un solo dataframe (tb_sim). Se calcula la media de la medida de validez para cada valor de K y se visualizan los resultados mediante un gráfico utilizando la biblioteca seaborn. Los puntos en el gráfico representan las medidas de validez para cada iteración, y los puntos y la línea azul representan la media para cada valor de K. La dispersión de puntos proporciona una idea de la variabilidad de la medida de validez para cada valor de K.</p>
<p>Paso 1: <code>K_seq = range(2, 11)</code> Definir una secuencia de valores para K (número de clústeres)</p>
<p>Paso 2: <code>tb_sim_list = []</code> Inicializar una lista para almacenar los resultados de cada iteración</p>
<p>Paso 3: <code>for iter in range(1, 51):</code> Realizar un bucle sobre las iteraciones de 1 a 50, al interior de este bucle se realizan los pasos 4, 5 y 6.</p>
<p>Paso 4: <code>ps_values = list(map(lambda k: ps_cv_k(k, tb_data=tb_pinturas_caract, cv_ratio=0.6), K_seq))</code> Calcular la medida de validez del clustering (PS) para cada valor de K</p>
<p>Paso 5: <code>iter_data = pd.DataFrame({...})</code> Crear un DataFrame con los resultados de la iteración actual</p>
<p>Paso 6: <code>tb_sim_list.append(iter_data)</code> Agregar los resultados a la lista</p>
<p>Paso 7: <code>tb_sim = pd.concat(tb_sim_list, ignore_index=True)</code> Concatenar los resultados de todas las iteraciones en un solo DataFrame</p>
<p>Paso 8: <code>tb_sim_mean = tb_sim.groupby('K')['PS'].mean().reset_index()</code> Calcular la media de la medida de validez del clustering para cada valor de K</p>
<p>Paso 9: <code>sns....</code> Crear un gráfico utilizando seaborn para visualizar los resultados</p>
</div>
</div>
</div>
<p>Luego de simular los resultados y obtener la medida promedio de la fuerza de predicción es necesario interpretar. Si la fuerza de predicción es alta (cercana a 1), significa que la estructura de grupos estimados es muy parecida a los verdaderos. Lo que indica que el método recupera aproximadamente los mismos grupos. Si la fuerza de predicción es baja significa que el algoritmo está encontrando distintos grupos al examinar los datos de prueba y al pronosticarlos mediante la estructura estimada usando los datos de entrenamiento. Esto puede suceder por dos motivos. 1. Puede ser que los datos no presenten una esstructura de agrupamiento, o 2. Puede ser que los hiperparámetros del algoritmo, como su número de grupos, o su distancia entre grupos (linkage) o su epsilon, sean incorrectos.</p>
</section>
<section id="coeficiente-silueta" class="level2">
<h2 class="anchored" data-anchor-id="coeficiente-silueta">Coeficiente Silueta</h2>
<p>El coeficiente silueta es una métrica de ajuste de un algoritmo de agrupación. También puede ser usado para la selección del número de grupos <span class="math inline">\(k\)</span> en una estimación de <span class="math inline">\(k\)</span>-means. El código es el siguiente.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-10-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-10-1" role="tab" aria-controls="tabset-10-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-10-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-10-2" role="tab" aria-controls="tabset-10-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-10-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-10-1-tab">
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_nbclust</span>(</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> tb_pinturas_caract, </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">FUNcluster =</span> kmeans, </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">method =</span> <span class="st">"silhouette"</span>,</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">k.max =</span> <span class="dv">15</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  ) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="unidad_03_files/figure-html/unnamed-chunk-21-3.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>El código utiliza la función <code>fviz_nbclust</code> para visualizar determinar el número óptimo de clusters en el conjunto de datos <code>tb_pinturas_caract</code>. La métrica evaluada es el coeficiente silueta, y la visualización permite identificar el número óptimo de clusters al observar el cambiuo en el coeficiente silueta en función del número de clusters.</p>
<ol type="1">
<li><p><strong><code>fviz_nbclust(...)</code></strong>: Utiliza la función <code>fviz_nbclust</code> del paquete <code>factoextra</code> en R para determinar el número óptimo de clusters en un conjunto de datos.</p></li>
<li><p><strong><code>x = tb_pinturas_caract</code></strong>: Se especifica que el conjunto de datos <code>tb_pinturas_caract</code> es el objeto en el que se realizará el análisis de clusters.</p></li>
<li><p><strong><code>FUNcluster = kmeans</code></strong>: Indica que se utilizará el algoritmo de k-means para realizar el análisis de clusters, utilizando la función <code>kmeans</code>.</p></li>
<li><p><strong><code>method = "silhouette"</code></strong>: Selecciona el método para determinar el número óptimo de clusters. En este caso, se utiliza “silhouette”, que es una medida de cuán bien definidos están los clusters.</p></li>
<li><p><strong><code>k.max = 15</code></strong>: Especifica el número máximo de clusters a considerar. En este caso, se evaluará hasta un máximo de 15 clusters.</p></li>
</ol>
</div>
<div id="tabset-10-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-10-2-tab">
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>k_values <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">16</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>kmeans_model <span class="op">=</span> KMeans(n_init <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>visualizer <span class="op">=</span> KElbowVisualizer(</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  kmeans_model, k<span class="op">=</span>k_values, metric<span class="op">=</span><span class="st">'silhouette'</span>, timings<span class="op">=</span><span class="va">False</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>visualizer <span class="op">=</span> visualizer.fit(tb_pinturas_caract)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>visualizer.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="unidad_03_files/figure-html/unnamed-chunk-22-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El código utiliza el método del codo para determinar el número óptimo de clusters en el conjunto de datos <code>tb_pinturas_caract</code> utilizando el algoritmo de k-medias. La visualización de la métrica de silhouette en función del número de clusters ayuda a identificar el punto en el que los clusters son más cohesivos y separados, lo que permite identificar el número óptimo de clusters para el conjunto de datos.</p>
<ol type="1">
<li><p><strong>Definición de <code>k_values</code></strong>: Se crea una secuencia de valores desde 2 hasta 15 para representar diferentes números de clusters.</p></li>
<li><p><strong>Inicialización de <code>kmeans_model</code></strong>: Se crea una instancia del modelo de KMeans (k-medias) con <code>n_init=1</code>, indicando que el algoritmo se ejecutará solo una vez con una inicialización diferente.</p></li>
<li><p><strong>Creación del visualizador <code>visualizer</code></strong>: Se utiliza <code>KElbowVisualizer</code> del paquete <code>yellowbrick</code> para visualizar la métrica de “silhouette” en función del número de clusters. La métrica de silhouette mide cuán similar es un objeto a su propio cluster (cohesión) en comparación con otros clusters (separación). Se utiliza <code>timings=False</code> para evitar la visualización de tiempos de ejecución.</p></li>
<li><p><strong>Ajuste del modelo al conjunto de datos</strong>: Se ajusta el modelo de k-medias al conjunto de datos <code>tb_pinturas_caract</code> utilizando el método <code>fit()</code> del visualizador.</p></li>
<li><p><strong>Visualización y cierre del gráfico</strong>: Se muestra la visualización generada por el visualizador y se cierra la figura gráfica después de ser visualizada.</p></li>
</ol>
</div>
</div>
</div>
<p>En el gráfico es posible ver el número óptimo de grupos. Pero también es importante aprender a calcular el coeficientes silueta para cualquier resultado. Por esta razón, incluimos los siguientes fragmentos de código.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-11-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-11-1" role="tab" aria-controls="tabset-11-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-11-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-11-2" role="tab" aria-controls="tabset-11-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-11-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-11-1-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>tb_grupos <span class="sc">%&gt;%</span> </span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(grupos_jerar) <span class="sc">%&gt;%</span> </span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">silhouette</span>(</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">dist</span>(tb_pinturas_caract)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span> summary <span class="sc">%&gt;%</span> <span class="fu">pluck</span>(<span class="st">"avg.width"</span>) <span class="ot">-&gt;</span> jerar_sil</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>tb_grupos <span class="sc">%&gt;%</span> </span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(grupos_kmeans) <span class="sc">%&gt;%</span> </span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">silhouette</span>(</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">dist</span>(tb_pinturas_caract)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span> summary <span class="sc">%&gt;%</span> <span class="fu">pluck</span>(<span class="st">"avg.width"</span>) <span class="ot">-&gt;</span> kmeans_sil</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol type="1">
<li><p>Se utiliza la función <code>pull</code> para extraer la columna de grupos jerárquicos (<code>grupos_jerar</code>) del dataframe <code>tb_grupos</code>.</p></li>
<li><p>Se aplica la función <code>silhouette</code> para calcular el coeficiente de silueta. Se utiliza la función <code>dist</code> para calcular la matriz de distancias entre las observaciones en <code>tb_pinturas_caract</code>.</p></li>
<li><p>Se utiliza la función <code>summary</code> para resumir los resultados del coeficiente de silueta.</p></li>
<li><p>Se utiliza la función <code>pluck</code> para extraer el ancho promedio del coeficiente de silueta y se almacena en la variable <code>jerar_sil</code>.</p></li>
</ol>
<p>Luego, se repite el mismo proceso para los grupos de k-means (<code>grupos_kmeans</code>) y se almacena el ancho promedio del coeficiente de silueta en la variable <code>kmeans_sil</code>.</p>
<p>Estos valores (<code>jerar_sil</code> y <code>kmeans_sil</code>) proporcionarán información sobre la calidad de la agrupación según el coeficiente de silueta para los grupos jerárquicos y de k-means, respectivamente. Un coeficiente de silueta más cercano a 1 indica una mejor separación y cohesión de los grupos.</p>
</div>
<div id="tabset-11-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-11-2-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>jerar_sil <span class="op">=</span> silhouette_score(tb_pinturas_caract, tb_grupos[<span class="st">"grupos_jerar"</span>])</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>kmeans_sil <span class="op">=</span>silhouette_score(tb_pinturas_caract, tb_grupos[<span class="st">"grupos_kmeans"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol type="1">
<li><p>Se utiliza la función <code>silhouette_score</code> de scikit-learn.</p></li>
<li><p><code>tb_pinturas_caract</code> es el conjunto de datos de características de las pinturas.</p></li>
<li><p><code>tb_grupos["grupos_jerar"]</code> proporciona los grupos jerárquicos asignados a cada observación.</p></li>
<li><p>El resultado se almacena en la variable <code>jerar_sil</code>.</p></li>
<li><p>Se utiliza la misma función <code>silhouette_score</code>.</p></li>
<li><p><code>tb_grupos["grupos_kmeans"]</code> proporciona los grupos de k-means asignados a cada observación.</p></li>
<li><p>El resultado se almacena en la variable <code>kmeans_sil</code>.</p></li>
</ol>
<p>El coeficiente de silueta es una medida de la calidad de la agrupación, y un valor más cercano a 1 indica una mejor separación y cohesión de los grupos. Estos valores (<code>jerar_sil</code> y <code>kmeans_sil</code>) proporcionarán información sobre la calidad de la agrupación para los grupos jerárquicos y de k-means, respectivamente.</p>
</div>
</div>
</div>
<p>¿Cuál es el resultado para el clustering jerárquico? ¿Cuál es el resultado para el algoritmo <span class="math inline">\(k\)</span>-means?</p>
</section>
</section>
<section id="interpretación" class="level1">
<h1>Interpretación</h1>
<p>En esta sección vamos a visualizar e interpretar los resultados de nuestro algoritmo de agrupamiento.</p>
<section id="visualización-de-los-grupos-conformados" class="level2">
<h2 class="anchored" data-anchor-id="visualización-de-los-grupos-conformados">Visualización de los grupos conformados</h2>
<p>En el siguiente código, hemos dispuesto la <strong>caracterización</strong> de los grupos conformados mediante el algoritmo <span class="math inline">\(k\)</span>-means. Utilizando el mapa de calor, hemos establecido las principales tendencias usando las siguientes etiquetas: <code>"RIVER"</code> (ríos), <code>"MOUNTAIN"</code> (montañas), <code>"AUTUMN"</code> (otoño), <code>"HOME"</code> (hogar), <code>"SEA"</code> (mar), <code>PEAK</code> (picos nevados) y <code>"WINTER"</code> (invierno). Podemos darnos cuenta de que, los resultados en python difieren de los resultados en R. Esto se debe a la fuerte dependencia que tiene <span class="math inline">\(k\)</span>-means sobre los puntos iniciales. Es muy probable que las agrupaciones generadas con otros métodos nos permitan encontrar otras etiquetas, en el código están los espacios para la interpretación.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-12-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-12-1" role="tab" aria-controls="tabset-12-1" aria-selected="true">R</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-12-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-12-2" role="tab" aria-controls="tabset-12-2" aria-selected="false">Python</a></li></ul>
<div class="tab-content">
<div id="tabset-12-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-12-1-tab">
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>, <span class="st">"D"</span>, <span class="st">"E"</span>, <span class="st">"F"</span>) <span class="ot">-&gt;</span> nombres_kmeans</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>, <span class="st">"D"</span>, <span class="st">"E"</span>, <span class="st">"F"</span>) <span class="ot">-&gt;</span> nombres_jerar</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>, <span class="st">"D"</span>, <span class="st">"E"</span>, <span class="st">"F"</span>) <span class="ot">-&gt;</span> nombres_dbscan</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>tb_grupos <span class="sc">%&gt;%</span> </span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Podemos cambiar este código para elegir otro agrupamiento</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># tendencia = nombres_jerar[grupos_jerar],</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">tendencia =</span> nombres_kmeans[grupos_kmeans],</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># tendencia = nombres_dbscan[grupos_dbscan + 1],</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span> </span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span><span class="fu">starts_with</span>(<span class="st">"grupos"</span>)) <span class="sc">%&gt;%</span> </span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">inner_join</span>(</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    tb_pinturas</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span> </span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(tendencia) <span class="sc">%&gt;%</span> </span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(<span class="fu">across</span>(is.numeric, mean)) <span class="ot">-&gt;</span> tb_centroides</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>tb_centroides <span class="sc">%&gt;%</span> </span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span> tendencia) <span class="sc">%&gt;%</span> </span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_dbl</span>(var) <span class="sc">%&gt;%</span> </span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>(<span class="at">rownames =</span> <span class="st">"item"</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">top_n</span>(<span class="dv">30</span>, value) <span class="sc">%&gt;%</span> </span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(item) <span class="ot">-&gt;</span> nm_items_relevantes</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>tb_centroides <span class="sc">%&gt;%</span> </span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gather</span>(<span class="st">"rotulo"</span>, <span class="st">"value"</span>, <span class="sc">-</span>tendencia) <span class="sc">%&gt;%</span> </span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(rotulo <span class="sc">%in%</span> nm_items_relevantes) <span class="sc">%&gt;%</span> </span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>  ggplot <span class="sc">+</span></span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> tendencia, <span class="at">y =</span> rotulo, <span class="at">fill =</span> value) <span class="sc">+</span></span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_raster</span>() <span class="sc">+</span></span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_text</span>(<span class="fu">aes</span>(<span class="at">label =</span> <span class="fu">percent</span>(value, <span class="at">accuracy =</span> <span class="fl">1.0</span>)), <span class="at">hjust =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_discrete</span>(<span class="at">name =</span> <span class="st">"Tendencias"</span>, <span class="at">position =</span> <span class="st">"top"</span>) <span class="sc">+</span></span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_y_discrete</span>(<span class="at">name =</span> <span class="st">"Objetos"</span>) <span class="sc">+</span></span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_fill_gradient</span>(<span class="at">high =</span> <span class="st">"#bb8899"</span>, <span class="at">low =</span> <span class="st">"#ffeeee"</span>, <span class="at">guide =</span> <span class="st">"none"</span>) <span class="sc">+</span></span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(</span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a>    <span class="at">axis.text.y =</span> <span class="fu">element_text</span>(<span class="at">hjust=</span><span class="dv">0</span>)</span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a>  ) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="unidad_03_files/figure-html/unnamed-chunk-25-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>Definición de Nombres de Grupos:</strong> Se definen nombres para los grupos obtenidos mediante k-medias, jerárquicos y DBSCAN.</p>
<p><strong>Creación de Centroides:</strong></p>
<ul>
<li><p>Se agrega una columna “tendencia” al dataframe <code>tb_grupos</code> basada en los nombres de los grupos de k-medias.</p></li>
<li><p>Se eliminan las columnas de grupos originales.</p></li>
<li><p>Se realiza una unión con el marco de datos <code>tb_pinturas</code>.</p></li>
<li><p>Se calculan los centroides (medias) de las variables numéricas para cada grupo.</p></li>
</ul>
<p><strong>Selección de Elementos Relevantes:</strong></p>
<ul>
<li>Se seleccionan las 30 variables con mayor varianza entre los centroides.</li>
</ul>
<p><strong>Visualización con ggplot2:</strong></p>
<ul>
<li><p>Se utiliza ggplot2 para representar gráficamente los elementos relevantes.</p></li>
<li><p>Se utiliza <code>geom_raster</code> para mostrar colores proporcionales a los valores.</p></li>
<li><p>Se utiliza <code>geom_text</code> para agregar etiquetas de porcentaje a los valores.</p></li>
<li><p>Se personalizan los ejes y la paleta de colores.</p></li>
</ul>
</div>
<div id="tabset-12-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-12-2-tab">
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>nombres_kmeans <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">range</span>(<span class="dv">6</span>),</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  [<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>, <span class="st">"D"</span>, <span class="st">"E"</span>, <span class="st">"F"</span>]</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>nombres_jerar <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">range</span>(<span class="dv">6</span>),</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  [<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>, <span class="st">"D"</span>, <span class="st">"E"</span>, <span class="st">"F"</span>]</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>nombres_dbscan <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>  [x <span class="op">-</span> <span class="dv">1</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>)],</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>  [<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>, <span class="st">"D"</span>, <span class="st">"E"</span>, <span class="st">"F"</span>]</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Podemos cambiar este código para elegir otro agrupamiento</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>tb_grupos[<span class="st">"tendencia"</span>] <span class="op">=</span> tb_grupos[<span class="st">"grupos_kmeans"</span>].<span class="bu">map</span>(nombres_kmeans)</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="co"># tb_grupos["tendencia"] = tb_grupos["grupos_jerar"].map(nombres_jerar)</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a><span class="co"># tb_grupos["tendencia"] = tb_grupos["grupos_dbscan"].map(nombres_dbscan)</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>tb_joined <span class="op">=</span> pd.merge(</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>  tb_grupos.drop(tb_grupos.<span class="bu">filter</span>(like<span class="op">=</span><span class="st">'grupos'</span>).columns, axis<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>  tb_pinturas,</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>  how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>tb_centroides <span class="op">=</span> (tb_joined</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>  .drop([<span class="st">"EPISODE"</span>, <span class="st">"TITLE"</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>  .groupby(<span class="st">'tendencia'</span>).agg(<span class="st">'mean'</span>))</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>nm_items_relevantes <span class="op">=</span> (tb_centroides</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>  .<span class="bu">apply</span>(np.var, axis <span class="op">=</span> <span class="dv">0</span>)</span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>  .sort_values()[<span class="op">-</span><span class="dv">30</span> :]</span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>  .index)</span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>tb_long <span class="op">=</span> pd.melt(</span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>  tb_centroides.reset_index(), </span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>  id_vars<span class="op">=</span>[<span class="st">'tendencia'</span>], var_name<span class="op">=</span><span class="st">'rotulo'</span>, value_name<span class="op">=</span><span class="st">'value'</span></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>tb_filtered <span class="op">=</span> tb_long[tb_long[<span class="st">'rotulo'</span>].isin(nm_items_relevantes)]</span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>custom_palette <span class="op">=</span> sns.color_palette(<span class="st">"blend:#fee,#b89"</span>, as_cmap<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a>sns.heatmap(</span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a>  pd.pivot_table(</span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>    tb_filtered, values<span class="op">=</span><span class="st">'value'</span>, index<span class="op">=</span><span class="st">'rotulo'</span>, columns<span class="op">=</span><span class="st">'tendencia'</span></span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a>  annot<span class="op">=</span><span class="va">True</span>, fmt<span class="op">=</span><span class="st">".1%"</span>, cmap <span class="op">=</span> custom_palette,</span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a>  cbar<span class="op">=</span><span class="va">False</span></span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Tendencias'</span>)</span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Objetos'</span>)</span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="unidad_03_files/figure-html/unnamed-chunk-26-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="960"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Definición de Nombres de Grupos:</strong> Se definen diccionarios para mapear los índices de los grupos a nombres representativos para k-medias, jerárquicos y DBSCAN.</p>
<p><strong>Mapeo de Tendencias:</strong> Se agrega una columna “tendencia” al marco de datos <code>tb_grupos</code> basada en los nombres de los grupos de k-medias (puedes cambiar esto para otros agrupamientos).</p>
<p><strong>Unión de Marcos de Datos:</strong> Se realiza una unión del marco de datos <code>tb_grupos</code> con <code>tb_pinturas</code> basada en las tendencias.</p>
<p><strong>Cálculo de Centroides:</strong> Se calculan los centroides (medias) para cada tendencia.</p>
<p><strong>Selección de Elementos Relevantes:</strong> Se seleccionan las 30 variables con mayor varianza entre los centroides.</p>
<p><strong>Derretir el Marco de Datos:</strong> Se derrete el marco de datos para facilitar su uso en seaborn.</p>
<p><strong>Visualización con Seaborn y Matplotlib:</strong></p>
<ul>
<li><p>Se utiliza seaborn para crear un mapa de calor utilizando el marco de datos derretido.</p></li>
<li><p>Se personaliza el mapa de calor y se muestra utilizando matplotlib.</p></li>
</ul>
</div>
</div>
</div>
</section>
<section id="análisis" class="level2">
<h2 class="anchored" data-anchor-id="análisis">Análisis</h2>
<p>A lo largo de los ejercicios de validación, hemos encontrado varias alternativas para dar soporte a nuestros resultados. Al respecto es necesario realizar un análisis de los resultados que hemos observado.</p>
<ol type="1">
<li><p>Los resultados no son estables: en los ejercicios de validación, podemos observar resultados inconsistentes. Al cambiar de método, al cambiar de lenguaje o al cambiar de métrica. En un principio, esto puede parecer confuso, pero obedece a una realidad evidente desde la unidad anterior. La estructura interna de los datos presenta dos grupos bien diferenciados. Un primer grupo con pinturas de playas, palmeras y océanos; y otro grupo con paisajes del interior. Los demás grupos no se encuentran lo suficientemente separados, de hecho se mezclan entre sí.</p></li>
<li><p>Las métricas de evaluación de los grupos realizados no son las más altas. De hecho, muchas veces tenemos un mejor ajuste para 2, 3 o 4 grupos. Esto hace que nuestras agrupaciones (6 grupos) no constituyan la forma más orgánica de agrupar las pinturas.</p></li>
<li><p>El más afectado es el algoritmo DBSCAN. Diseñado para capturar estructuras de grupos bien definidos, el algoritmo DBSCAN en este escenario no ha tenido un buen desempeño, generando grupos de tamaños muy diferentes y etiquetando como ruido a la mayoría de las observaciones. Se trata de un algoritmo que debe ser usado en problemas con grupos más separados.</p></li>
<li><p>Aunque la falta de una estructura de grupos en los datos le resta estabilidad a los algoritmos, es posible llegar a una caracterización definida. Hemos logrado obtener caracterizaciones de las pinturas forzando los grupos.</p></li>
</ol>
</section>
</section>
<section id="conclusión" class="level1">
<h1>Conclusión</h1>
<p>Hemos terminado de analizar nuestro dataset. Ya tenemos nuestros grupos conformados. A pesar de que no son los grupos óptimos, nos han permitido tener una visión más profunda de la naturaleza de las pinturas de Bob Ross y comprender los tipos de cuadros que fueron pintados durante la emisión de su programa.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>